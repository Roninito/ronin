/**
 * Ronin Menubar Status Indicator
 *
 * Provides macOS menubar integration showing:
 * - Ronin Desktop Mode status
 * - Recent files/texts submenu
 * - Quick actions
 * - Enable/disable toggle
 * - Offline mode toggle
 * - Clipboard toggle
 * - Event emission for state changes
 */

import { execSync } from "child_process";
import { existsSync, writeFileSync } from "fs";
import { join } from "path";
import { homedir } from "os";

// Event emitter for menubar state changes
export interface MenubarEventEmitter {
  emit(event: string, data: any): void;
}

export interface MenubarRoute {
  path: string;
  title: string;
  icon?: string;
}

export interface MenubarState {
  enabled: boolean;
  clipboardEnabled: boolean;
  offlineMode: boolean;
  aiProvider: "local" | "grok" | "gemini";
  recentFiles: number;
  recentTexts: number;
  osBridgeActive: boolean;
  lastSync?: Date;
  routes?: MenubarRoute[];
}

export interface MenubarCallbacks {
  onToggleDesktop?: (enabled: boolean) => void;
  onToggleOffline?: (enabled: boolean) => void;
  onToggleClipboard?: (enabled: boolean) => void;
  onSwitchAIProvider?: (provider: "local" | "grok" | "gemini") => void;
  onOpenDashboard?: () => void;
  onViewRecentFiles?: () => void;
  onViewRecentTexts?: () => void;
  onQuit?: () => void;
}

const MENUBAR_SCRIPT_PATH = join(homedir(), ".ronin", "menubar.scpt");

// Default event emitter (noop if not provided)
let eventEmitter: MenubarEventEmitter = {
  emit: () => {},
};

// Default callbacks
let callbacks: MenubarCallbacks = {};

/**
 * Set the event emitter for menubar events
 */
export function setEventEmitter(emitter: MenubarEventEmitter): void {
  eventEmitter = emitter;
}

/**
 * Set callbacks for menubar actions
 */
export function setCallbacks(cb: MenubarCallbacks): void {
  callbacks = { ...callbacks, ...cb };
}

/** Escape string for use inside an AppleScript double-quoted string */
function escapeForAppleScript(s: string): string {
  return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
}

/**
 * Generate AppleScript for menubar app using ASOC (AppKit/Foundation).
 * Builds a real dropdown: Open Dashboard, Routes submenu (one item per route), separator, Quit.
 * Script should be run as a Stay-open application for stability.
 */
function generateMenubarScript(port: number, routes: MenubarRoute[] = []): string {
  const dashboardUrl = `http://localhost:${port}/`;
  const escapedDashboardUrl = escapeForAppleScript(dashboardUrl);

  const routeItemsCode = routes
    .map((r) => {
      const url = `http://localhost:${port}${r.path}`;
      const escapedUrl = escapeForAppleScript(url);
      const escapedTitle = escapeForAppleScript(r.title);
      return `	set routeItem to (current application's NSMenuItem's alloc()'s initWithTitle:"${escapedTitle}" action:"openRoute:" keyEquivalent:"")
	(routeItem's setTarget:me)
	(routeItem's setRepresentedObject:(current application's NSString's stringWithString:"${escapedUrl}"))
	(routesMenu's addItem:routeItem)`;
    })
    .join("\n");

  return `-- Ronin Menubar (ASOC)
-- Generated by Ronin Desktop Mode. Run as Stay-open application for stability.

use AppleScript version "2.4"
use scripting additions
use framework "Foundation"
use framework "AppKit"

property statusItem : missing value
property mainMenu : missing value
property routesMenu : missing value

if not (current application's NSThread's isMainThread()) as boolean then
	display alert "Ronin Menubar must run on the main thread." buttons {"Quit"} as critical
	error number -128
end if

on run
	my makeStatusBar()
	-- Keep running
	repeat
		delay 5
	end repeat
end run

on makeStatusBar()
	set bar to current application's NSStatusBar's systemStatusBar()
	set statusItem to bar's statusItemWithLength:-1.0
	(statusItem's setTitle:"ðŸ¥·")
	set mainMenu to (current application's NSMenu's alloc()'s initWithTitle:"Ronin")
	(statusItem's setMenu:mainMenu)

	-- Open Dashboard
	set dashboardItem to (current application's NSMenuItem's alloc()'s initWithTitle:"Open Dashboard" action:"openDashboard:" keyEquivalent:"")
	(dashboardItem's setTarget:me)
	(mainMenu's addItem:dashboardItem)

	-- Routes submenu
	set routesMenu to (current application's NSMenu's alloc()'s initWithTitle:"Routes")
	set routesItem to (current application's NSMenuItem's alloc()'s initWithTitle:"Routes" action:missing value keyEquivalent:"")
	(routesItem's setSubmenu:routesMenu)
	(mainMenu's addItem:routesItem)

${routeItemsCode}

	(mainMenu's addItem:(current application's NSMenuItem's separatorItem()))

	-- Quit
	set quitItem to (current application's NSMenuItem's alloc()'s initWithTitle:"Quit Ronin Menubar" action:"quitApp:" keyEquivalent:"")
	(quitItem's setTarget:me)
	(mainMenu's addItem:quitItem)
end makeStatusBar

on openDashboard:sender
	do shell script "open " & quoted form of "${escapedDashboardUrl}"
end openDashboard:

on openRoute:sender
	set theURL to (sender's representedObject()) as text
	do shell script "open " & quoted form of theURL
end openRoute:

on quitApp:sender
	current application's NSApplication's sharedApplication()'s terminate:(me)
end quitApp:

on quit
	continue quit
end quit`;
}

/**
 * Check if a menubar app is running
 */
export function isMenubarRunning(): boolean {
  try {
    execSync("pgrep -f 'Ronin Menubar'", { stdio: "pipe" });
    return true;
  } catch {
    return false;
  }
}

/**
 * Start menubar app with optional routes for the Routes submenu.
 * Routes are discovered from registered HTTP routes (e.g. /todo, /analytics).
 */
export function startMenubar(port: number = 17341, routes: MenubarRoute[] = []): boolean {
  try {
    if (isMenubarRunning()) {
      console.log("[menubar] Menubar already running");
      return true;
    }

    // Write menubar script (includes routes submenu and click handlers when routes provided)
    const script = generateMenubarScript(port, routes);
    writeFileSync(MENUBAR_SCRIPT_PATH, script);

    // Launch in background
    execSync(`osascript "${MENUBAR_SCRIPT_PATH}" &`, {
      detached: true,
      stdio: "ignore",
    });

    console.log("[menubar] Started menubar indicator");
    eventEmitter.emit("menubar.started", { port, timestamp: Date.now() });
    return true;
  } catch (error) {
    console.error("[menubar] Failed to start menubar:", error);
    eventEmitter.emit("menubar.error", { error, timestamp: Date.now() });
    return false;
  }
}

/**
 * Stop menubar app
 */
export function stopMenubar(): boolean {
  try {
    execSync("pkill -f 'Ronin Menubar'", { stdio: "ignore" });
    console.log("[menubar] Stopped menubar indicator");
    eventEmitter.emit("menubar.stopped", { timestamp: Date.now() });
    return true;
  } catch {
    // Process not running
    return true;
  }
}

/**
 * Show native macOS menu (alternative to persistent menubar)
 */
export function showMenu(state: MenubarState): void {
  const menuItems = [
    `ðŸ¥· Ronin Desktop: ${state.enabled ? "âœ…" : "âŒ"}`,
    `ðŸ“¡ OS Bridge: ${state.osBridgeActive ? "âœ… Active" : "âŒ Inactive"}`,
    `ðŸ¤– AI: ${state.aiProvider === "local" ? "ðŸ–¥ï¸ Local" : state.aiProvider === "offline" ? "ðŸ“´ Offline" : "â˜ï¸ " + state.aiProvider}`,
    `ðŸ“‹ Clipboard: ${state.clipboardEnabled ? "âœ…" : "âŒ"}`,
    "---",
    `ðŸ“ Recent Files (${state.recentFiles})`,
    `ðŸ“ Recent Texts (${state.recentTexts})`,
    "---",
    state.enabled ? "â¸ï¸ Disable Desktop Mode" : "â–¶ï¸ Enable Desktop Mode",
    state.offlineMode ? "ðŸŒ Disable Offline Mode" : "ðŸ“´ Enable Offline Mode",
    state.clipboardEnabled ? "ðŸ“‹ Disable Clipboard" : "ðŸ“‹ Enable Clipboard",
    "ðŸ”„ Switch AI Provider",
    "---",
    "ðŸŒ Open Dashboard",
    state.lastSync ? `ðŸ• Last Sync: ${state.lastSync.toLocaleTimeString()}` : "ðŸ• Not synced",
    "---",
    "âŒ Quit Ronin Menubar",
  ];

  const script = `
    set menuItems to {${menuItems
      .map((item) => `"${item.replace(/"/g, '\\"')}"`)
      .join(", ")}}
    set selectedItem to choose from list menuItems with title "ðŸ¥· Ronin Desktop" with prompt "Select an action:"
    return selectedItem
  `;

  try {
    const result = execSync(`osascript -e '${script}'`, { encoding: "utf-8" });
    handleMenuSelection(result.trim(), state);
  } catch {
    // User cancelled
    eventEmitter.emit("menubar.menu.cancelled", { timestamp: Date.now() });
  }
}

/**
 * Handle menu selection
 */
function handleMenuSelection(selection: string, state: MenubarState): void {
  const timestamp = Date.now();

  switch (selection) {
    case "â–¶ï¸ Enable Desktop Mode":
      console.log("[menubar] Enabling Desktop Mode...");
      eventEmitter.emit("menubar.desktop.enabled", { previous: false, current: true, timestamp });
      callbacks.onToggleDesktop?.(true);
      showNotification({
        title: "Ronin Desktop",
        message: "Desktop Mode enabled",
        sound: false,
      });
      break;

    case "â¸ï¸ Disable Desktop Mode":
      console.log("[menubar] Disabling Desktop Mode...");
      eventEmitter.emit("menubar.desktop.disabled", { previous: true, current: false, timestamp });
      callbacks.onToggleDesktop?.(false);
      showNotification({
        title: "Ronin Desktop",
        message: "Desktop Mode disabled",
        sound: false,
      });
      break;

    case "ðŸ“´ Enable Offline Mode":
      console.log("[menubar] Enabling Offline Mode...");
      eventEmitter.emit("menubar.offline.enabled", { previous: false, current: true, timestamp });
      callbacks.onToggleOffline?.(true);
      showNotification({
        title: "Ronin Desktop",
        message: "Offline Mode enabled - Using local AI only",
        sound: false,
      });
      break;

    case "ðŸŒ Disable Offline Mode":
      console.log("[menubar] Disabling Offline Mode...");
      eventEmitter.emit("menubar.offline.disabled", { previous: true, current: false, timestamp });
      callbacks.onToggleOffline?.(false);
      showNotification({
        title: "Ronin Desktop",
        message: "Offline Mode disabled - Cloud AI available",
        sound: false,
      });
      break;

    case "ðŸ“‹ Enable Clipboard":
      console.log("[menubar] Enabling Clipboard...");
      eventEmitter.emit("menubar.clipboard.enabled", { previous: false, current: true, timestamp });
      callbacks.onToggleClipboard?.(true);
      showNotification({
        title: "Ronin Desktop",
        message: "Clipboard monitoring enabled",
        sound: false,
      });
      break;

    case "ðŸ“‹ Disable Clipboard":
      console.log("[menubar] Disabling Clipboard...");
      eventEmitter.emit("menubar.clipboard.disabled", { previous: true, current: false, timestamp });
      callbacks.onToggleClipboard?.(false);
      showNotification({
        title: "Ronin Desktop",
        message: "Clipboard monitoring disabled",
        sound: false,
      });
      break;

    case "ðŸ”„ Switch AI Provider":
      showAIProviderMenu(state);
      break;

    case "ðŸ“ Recent Files":
    case `ðŸ“ Recent Files (${state.recentFiles})`:
      eventEmitter.emit("menubar.recentfiles.viewed", { count: state.recentFiles, timestamp });
      callbacks.onViewRecentFiles?.();
      break;

    case "ðŸ“ Recent Texts":
    case `ðŸ“ Recent Texts (${state.recentTexts})`:
      eventEmitter.emit("menubar.recenttexts.viewed", { count: state.recentTexts, timestamp });
      callbacks.onViewRecentTexts?.();
      break;

    case "ðŸŒ Open Dashboard":
      eventEmitter.emit("menubar.dashboard.opened", { timestamp });
      callbacks.onOpenDashboard?.();
      try {
        execSync("open http://localhost:3000");
      } catch {
        showNotification({
          title: "Ronin Desktop",
          message: "Dashboard not running. Start Ronin first.",
          sound: true,
        });
      }
      break;

    case "âŒ Quit Ronin Menubar":
      eventEmitter.emit("menubar.quit", { timestamp });
      callbacks.onQuit?.();
      stopMenubar();
      break;

    default:
      // Handle sync status clicks
      if (selection.includes("Last Sync")) {
        eventEmitter.emit("menubar.sync.clicked", { lastSync: state.lastSync, timestamp });
      }
  }
}

/**
 * Show AI Provider selection menu
 */
function showAIProviderMenu(state: MenubarState): void {
  const providers = [
    state.aiProvider === "local" ? "â— ðŸ–¥ï¸ Local (Ollama)" : "â—‹ ðŸ–¥ï¸ Local (Ollama)",
    state.aiProvider === "grok" ? "â— â˜ï¸ Grok" : "â—‹ â˜ï¸ Grok",
    state.aiProvider === "gemini" ? "â— â˜ï¸ Gemini" : "â—‹ â˜ï¸ Gemini",
    "---",
    "â†©ï¸ Back",
  ];

  const script = `
    set menuItems to {${providers.map((item) => `"${item}"`).join(", ")}}
    set selectedItem to choose from list menuItems with title "ðŸ¤– Select AI Provider" with prompt "Choose AI provider:"
    return selectedItem
  `;

  try {
    const result = execSync(`osascript -e '${script}'`, { encoding: "utf-8" });
    const selection = result.trim();

    if (selection.includes("Local")) {
      eventEmitter.emit("menubar.ai.changed", { previous: state.aiProvider, current: "local", timestamp: Date.now() });
      callbacks.onSwitchAIProvider?.("local");
      showNotification({
        title: "Ronin Desktop",
        message: "Switched to Local AI (Ollama)",
        sound: false,
      });
    } else if (selection.includes("Grok")) {
      eventEmitter.emit("menubar.ai.changed", { previous: state.aiProvider, current: "grok", timestamp: Date.now() });
      callbacks.onSwitchAIProvider?.("grok");
      showNotification({
        title: "Ronin Desktop",
        message: "Switched to Grok AI",
        sound: false,
      });
    } else if (selection.includes("Gemini")) {
      eventEmitter.emit("menubar.ai.changed", { previous: state.aiProvider, current: "gemini", timestamp: Date.now() });
      callbacks.onSwitchAIProvider?.("gemini");
      showNotification({
        title: "Ronin Desktop",
        message: "Switched to Gemini AI",
        sound: false,
      });
    }
  } catch {
    // User cancelled
  }
}

/**
 * Show notification via menubar
 */
export function showNotification(options: {
  title: string;
  message: string;
  subtitle?: string;
  sound?: boolean;
  actions?: string[];
}): void {
  let script = `display notification "${options.message.replace(/"/g, '\\"')}" with title "${options.title}"`;

  if (options.subtitle) {
    script += ` subtitle "${options.subtitle.replace(/"/g, '\\"')}"`;
  }

  if (options.sound) {
    script += ` sound name "default"`;
  }

  try {
    execSync(`osascript -e '${script}'`);
    eventEmitter.emit("menubar.notification.shown", {
      title: options.title,
      message: options.message,
      timestamp: Date.now(),
    });
  } catch (error) {
    console.error("[menubar] Failed to show notification:", error);
  }
}

/**
 * Update menubar with current state
 */
export function updateMenubarState(state: Partial<MenubarState>): void {
  // Update the menubar display
  // Full implementation would communicate with the running menubar app
  console.log("[menubar] State updated:", state);
  eventEmitter.emit("menubar.state.updated", { state, timestamp: Date.now() });
}

/**
 * Emit a custom menubar event
 */
export function emitMenubarEvent(event: string, data: any): void {
  eventEmitter.emit(`menubar.${event}`, { ...data, timestamp: Date.now() });
}

/**
 * Get current menubar state
 */
export function getMenubarState(): MenubarState {
  return {
    enabled: false,
    clipboardEnabled: false,
    offlineMode: false,
    aiProvider: "local",
    recentFiles: 0,
    recentTexts: 0,
    osBridgeActive: false,
    routes: [],
  };
}

/**
 * Discover routes from HTTPAPI based on configuration
 */
export function discoverRoutes(
  getAllRoutes: () => Map<string, (req: Request) => Response | Promise<Response>>,
  getRouteMetadata: (path: string) => {title?: string, description?: string, icon?: string} | undefined,
  config?: {
    enabled?: boolean;
    allowedPaths?: string[];
    includePatterns?: string[];
    excludePatterns?: string[];
    maxItems?: number;
  }
): MenubarRoute[] {
  if (!config?.enabled) {
    return [];
  }

  const routes = getAllRoutes();
  const result: MenubarRoute[] = [];
  const maxItems = config.maxItems || 10;
  const allowedPaths = config.allowedPaths;

  if (allowedPaths && allowedPaths.length > 0) {
    // Only include routes whose path is in allowedPaths (exact or prefix match); "/" allows all
    for (const [path] of routes.entries()) {
      const allowed = allowedPaths.some(
        (p) => path === p || p === "/" || (p !== "/" && path.startsWith(p + "/"))
      );
      if (!allowed) continue;
      const metadata = getRouteMetadata(path);
      result.push({
        path,
        title: metadata?.title || path,
        icon: metadata?.icon
      });
      if (result.length >= maxItems) break;
    }
    return result.sort((a, b) => a.path.localeCompare(b.path));
  }

  const excludePatterns = config.excludePatterns || ['/api/'];
  const includePatterns = config.includePatterns || [];

  for (const [path] of routes.entries()) {
    if (excludePatterns.some(pattern => path.includes(pattern))) {
      continue;
    }
    if (includePatterns.length > 0 && !includePatterns.some(pattern => path.includes(pattern))) {
      continue;
    }

    const metadata = getRouteMetadata(path);
    result.push({
      path,
      title: metadata?.title || path,
      icon: metadata?.icon
    });

    if (result.length >= maxItems) {
      break;
    }
  }

  return result.sort((a, b) => a.path.localeCompare(b.path));
}

// Export types
export type { MenubarState, MenubarCallbacks, MenubarEventEmitter };
